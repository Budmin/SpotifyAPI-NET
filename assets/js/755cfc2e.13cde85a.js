"use strict";(self.webpackChunkspotify_api_docs=self.webpackChunkspotify_api_docs||[]).push([[5003],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),g=s(n),d=r,f=g["".concat(p,".").concat(d)]||g[d]||u[d]||i;return n?a.createElement(f,o(o({ref:t},c),{},{components:n})):a.createElement(f,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=g;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},210:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return p},default:function(){return d},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={id:"pagination",title:"Pagination"},p=void 0,s={unversionedId:"pagination",id:"pagination",title:"Pagination",description:"When working with Spotify responses, you will often encounter the Paging type.",source:"@site/docs/pagination.md",sourceDirName:".",slug:"/pagination",permalink:"/SpotifyAPI-NET/docs/pagination",draft:!1,editUrl:"https://github.com/JohnnyCrazy/SpotifyAPI-NET/edit/master/SpotifyAPI.Docs/docs/pagination.md",tags:[],version:"current",lastUpdatedBy:"dependabot[bot]",lastUpdatedAt:1681239311,formattedLastUpdatedAt:"Apr 11, 2023",frontMatter:{id:"pagination",title:"Pagination"},sidebar:"docs",previous:{title:"Proxy",permalink:"/SpotifyAPI-NET/docs/proxy"},next:{title:"Retry Handling",permalink:"/SpotifyAPI-NET/docs/retry_handling"}},c={},u=[{value:"PaginateAll",id:"paginateall",level:2},{value:"Paginate",id:"paginate",level:2},{value:"Paginators",id:"paginators",level:2}],g={toc:u};function d(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When working with Spotify responses, you will often encounter the ",(0,i.kt)("inlineCode",{parentName:"p"},"Paging<T>")," type."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The offset-based paging object is a container for a set of objects. It contains a key called Items (whose value is an array of the requested objects) along with other keys like Previous, Next and Limit which can be useful in future calls.")),(0,i.kt)("p",null,"It allows you to only receive a subset of all available data and dynamically check if more requests are required. The library supports ",(0,i.kt)("inlineCode",{parentName:"p"},"Paging<T>")," responses in two ways:"),(0,i.kt)("h2",{id:"paginateall"},"PaginateAll"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"PaginateAll")," will query all remaining elements based on a first page and return all of them in an ",(0,i.kt)("inlineCode",{parentName:"p"},"IList"),". This method should not be used for huge amounts of pages (e.g ",(0,i.kt)("inlineCode",{parentName:"p"},"Search")," Endpoint), since it stores every response in memory."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// we need the first page\nvar page = await spotify.Playlists.CurrentUsers();\n\n// allPages will include the first page retrived before\nvar allPages = await spotify.PaginateAll(page);\n")),(0,i.kt)("h2",{id:"paginate"},"Paginate"),(0,i.kt)("admonition",{title:".NET Standard >= 2.1 required",type:"info"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Paginate")," is based on ",(0,i.kt)("inlineCode",{parentName:"p"},"IAsyncEnumerable")," and streams pages instead of returning them all in one list. This allows it to break the fetching early and keep only 1 page in memory at a time. This method should always be preferred to ",(0,i.kt)("inlineCode",{parentName:"p"},"PaginateAll"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'// we need the first page\nvar page = await spotify.Playlists.CurrentUsers();\n\nawait foreach(var item in spotify.Paginate(page))\n{\n  Console.WriteLine(item.Name);\n  // you can use "break" here!\n}\n')),(0,i.kt)("p",null,"Some endpoints have nested and/or multiple paginations objects. When requesting the next page, it will not return the actual paging object but rather the root level endpoint object. A good example is the ",(0,i.kt)("inlineCode",{parentName:"p"},"Search")," endpoint, which contains up to 5 Paging objects. Requesting the next page of the nested ",(0,i.kt)("inlineCode",{parentName:"p"},"Artists")," paging object will return another ",(0,i.kt)("inlineCode",{parentName:"p"},"Search")," response, instead of just ",(0,i.kt)("inlineCode",{parentName:"p"},"Artists"),". You will need to supply a mapper function to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Paginate")," call, which returns the correct paging object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'var search = await spotify.Search.Item(new SearchRequest(\n  SearchRequest.Types.All, "Jake"\n));\n\nawait foreach(var item in spotify.Paginate(search.Albums, (s) => s.Albums))\n{\n  Console.WriteLine(item.Name);\n  // you can use "break" here!\n}\n')),(0,i.kt)("h2",{id:"paginators"},"Paginators"),(0,i.kt)("p",null,"Via the interface ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/JohnnyCrazy/SpotifyAPI-NET/blob/master/SpotifyAPI.Web/Clients/Interfaces/IPaginator.cs"},(0,i.kt)("inlineCode",{parentName:"a"},"IPaginator")),", it can be configured how pages are fetched. It can be configured on a global level:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var config = SpotifyClientConfig\n  .CreateDefault()\n  .WithPaginator(new YourCustomPaginator());\n")),(0,i.kt)("p",null,"or on method level:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'await foreach(var item in spotify.Paginate(page, new YourCustomPaginator()))\n{\n  Console.WriteLine(item.Name);\n  // you can use "break" here!\n}\n')),(0,i.kt)("p",null,"By default, ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/JohnnyCrazy/SpotifyAPI-NET/blob/master/SpotifyAPI.Web/Clients/SimplePaginator.cs"},(0,i.kt)("inlineCode",{parentName:"a"},"SimplePaginator"))," is used. It fetches pages without any delay."))}d.isMDXComponent=!0}}]);